declare class Vector3 {
    x: number;
    y: number;
    z: number;
    constructor(x?: number, y?: number, z?: number);
    set(x: number, y: number, z?: number): this;
    setXYZ({ x, y, z }: {
        x: any;
        y: any;
        z: any;
    }): this;
    size(): number;
    length(): number;
    copy(v: Vector3): Vector3;
    cross(v: Vector3): Vector3;
    divide(v: Vector3): Vector3;
    divideScalar(scalar: number): Vector3;
    fromBufferAttribute(attribute: any, index: any): this;
    setScalar(scalar: any): this;
    setX(x: any): this;
    setY(y: any): this;
    setZ(z: any): this;
    setComponent(index: any, value: any): this;
    getComponent(index: any): number;
    clone(): Vector3;
    add(v: any): this;
    addScalar(s: any): this;
    addVectors(a: any, b: any): this;
    addScaledVector(v: any, s: any): this;
    sub(v: any): this;
    subScalar(s: any): this;
    subVectors(a: any, b: any): this;
    multiply(v: any): this;
    multiplyScalar(scalar: any): this;
    multiplyVectors(a: any, b: any): this;
    applyEuler(euler: any): this;
    applyAxisAngle(axis: any, angle: any): this;
    applyMatrix3(m: any): this;
    applyNormalMatrix(m: any): Vector3;
    applyMatrix4(m: any): this;
    applyQuaternion(q: any): this;
    project(camera: any): this;
    unproject(camera: any): this;
    transformDirection(m: any): Vector3;
    min(v: any): this;
    max(v: any): this;
    clamp(min: any, max: any): this;
    clampScalar(minVal: any, maxVal: any): this;
    clampLength(min: any, max: any): Vector3;
    floor(): this;
    ceil(): this;
    round(): this;
    roundToZero(): this;
    negate(): this;
    dot(v: any): number;
    lengthSq(): number;
    manhattanLength(): number;
    normalize(): Vector3;
    setLength(length: any): Vector3;
    lerp(v: any, alpha: any): this;
    lerpVectors(v1: any, v2: any, alpha: any): this;
    crossVectors(a: any, b: any): this;
    projectOnVector(v: any): Vector3;
    projectOnPlane(planeNormal: any): this;
    reflect(normal: any): this;
    angleTo(v: any): number;
    distanceTo(v: any): number;
    distanceToSquared(v: any): number;
    manhattanDistanceTo(v: any): number;
    setFromSpherical(s: any): this;
    setFromSphericalCoords(radius: any, phi: any, theta: any): this;
    setFromCylindrical(c: any): this;
    setFromCylindricalCoords(radius: any, theta: any, y: any): this;
    setFromMatrixPosition(m: any): this;
    setFromMatrixScale(m: any): this;
    setFromMatrixColumn(m: any, index: any): this;
    setFromMatrix3Column(m: any, index: any): this;
    setFromEuler(e: any): this;
    setFromColor(c: any): this;
    equals(v: any): boolean;
    fromArray(array: any, offset?: number): this;
    toArray(array?: any[], offset?: number): any[];
    random(): this;
    randomDirection(): this;
    [Symbol.iterator](): Generator<number, void, unknown>;
}
export { Vector3 };
